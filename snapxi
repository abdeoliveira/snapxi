#!/usr/bin/ruby
#===============
@device = '/dev/mapper/luks-cb826ef1-c466-4b9b-b11c-2b7b8fab5210' 
@snapdir = '/.snapshots'
@snapvol = '@snapshots'
@rootvol = '@root'
#===============
unless ENV['USER'] == 'root'
  puts "You should run as root. ABORTED."
  abort
end
#==========================
if File.file?'/tmp/snapxi-kernel-update'
  puts "It seems you have upgraded the kernel recently without rebooting.\n\
It is strongly recommended you reboot into the new kernel before using snapxi.\n\
ABORTED."
  abort
end
#==========================
def now
 Time.new.strftime "%Y.%m.%d;%H:%M:%S"
end
#==========================
def letters
 return [*'a'..'z',*'A'..'Z']
end
#==========================
def snapid
  ids = `btrfs subvolume list / | grep #{@snapvol}/`
  id_list=[]
  ids.split("\n").each do |i|
    id_list<<i.split('/')[1].to_i
  end
  return id_list.sort
end
#==========================
def snapshot(comm,fake)
  comm = comm.gsub(';','')
  id = snapid.last.to_i + 1
  path = @snapdir + '/' + id.to_s
  ker = `uname -r`.chomp
  `mkdir #{path}`
  if comm.nil? then comm = 'manual' end
  unless fake 
    puts `btrfs subvolume snapshot / #{path}/data` 
  end
  info = "#{now};#{comm};#{ker}"
  File.write("#{path}/info",info,mode:'w')
end
#==========================
def splitstr(string,shift)
  max = 40
  line = ''
  total = 0
  string.split(' ').each do |s|
    scut = s[0..max]
    total = total + scut.size
    if total < max
      line = line + scut + ' '
    else
      total = scut.size
      line = line + "\n" + ' '*shift + scut + ' ' 
    end
  end
  return line
end
#==========================
def readinfo(id)
  path = @snapdir + '/' + id.to_s
  info = File.read(path + '/info').strip.split(';')
  date  = info[0]
  time  = info[1]
  desc  = info[2]
  ker  = info[3]
  comm = splitstr(desc,40)
  return [date,time,comm,ker]
end
#==========================
def list
    pklist = '' 
    line = 85
    puts "="*line
    puts " "*(line/2)+"SNAPSHOTS"
    puts "="*line
    puts ' '*3+"ID"\
      +' '*6+"DATE"\
      +' '*7+"TIME"\
      +' '*4+"KERNEL"\
      +' '*4+"COMMENT"
    puts "-"*line
    snapid.each do |id|
      date = readinfo(id)[0]
      time = readinfo(id)[1]
      comm = readinfo(id)[2]
      ker = readinfo(id)[3]
      #--------------------
      space = ' '*(4-id.to_s.size)
      kspace = 10 - ker.size
      #--------------------
      puts space\
        +'['+id.to_s+']'\
        +' '*2+date\
        +' '*2+time\
        +' '*2+ker\
        +' '*kspace+comm\
        +' '*11+pklist.strip
    end
    puts "-"*line 
end
#============================
def rollback
  timer = 5 # seconds before rebooting
  rollid = ARGV[1]
  if rollid.nil?
   puts "Choose a snapshot ID to rollback or type any letter to ABORT:"
   rollid = STDIN.gets.strip
  end
  if letters.include? rollid
    puts 'ABORTED.'
    abort
  end
  unless `ls #{@snapdir}/#{rollid} > /dev/null 2>&1; echo $?`.to_i == 0
    puts "There is no ID [#{rollid}]. ABORTED"
    abort
  end
  #----------------------
  kernel_from = `uname -r`.chomp 
  kernel_to = readinfo(rollid)[3]
  if kernel_from != kernel_to
    puts "Running kernel (#{kernel_from}) is\
 different from snapshot [#{rollid}] kernel (#{kernel_to}).\nABORTED."
    abort
  end
  #-----------------------
  puts "Rolling back to the following snapshot:"
  showinfo(rollid)
  puts "Confirm? [y/N]"
  if STDIN.gets.chomp == 'y' 
    `mount -o subvolid=5 #{@device} /mnt`
    #----------------
    unless `ls /mnt/#{@rootvol} > /dev/null 2>&1; echo $?`.to_i == 0 \
        and `ls /mnt/#{@snapvol} > /dev/null 2>&1; echo $?`.to_i == 0
      puts "Mounting stage went wrong. ABORTED."
      `umount /mnt`
      abort
    end
    #----------------
    id = snapid.last + 1
    snapshot("pre rollback to [#{rollid}]",true)
    `mv /mnt/#{@rootvol} /mnt/#{@snapvol}/#{id}/data`
    `btrfs subvolume snapshot /mnt/#{@snapvol}/#{rollid}/data /mnt/#{@rootvol}`
    `umount /mnt`
    root_id = `btrfs subvolume list / | grep #{@rootvol}`.split(' ')[1].to_i
    `btrfs subvolume set-default #{root_id} /`
    puts "Confirmed. Rebooting in..."
      timer.times do |i| 
        puts timer-=1
        sleep 1
      end
      puts 'Buckle up!'
    `reboot`
    else
      puts "ABORTED."
    end
end
#==================================
def showinfo(id)
  date = readinfo(id)[0]
  time = readinfo(id)[1]
  comm = readinfo(id)[2]
  ker = readinfo(id)[3]
  puts "[#{id}] #{date} #{time} #{ker} #{comm}" 
end
#==================================
def delete
  delid = ARGV[1]
  marked_for_deletion=[]
  if delid.nil?
    puts "Select snapshot(s) to delete or type any letter to ABORT:"
    delid = STDIN.gets.chomp
  end
  if letters.include? delid 
    puts "ABORTED."
    abort
  end
  if delid.include? '-'
    delid_i = delid.split('-').first.to_i
    delid_f = delid.split('-').last.to_i
    if delid_i >= delid_f 
      puts "Bad range. ABORTED."
      abort 
    end
    snapid.each do |id|
      if id >= delid_i and id <= delid_f 
          showinfo(id) 
          marked_for_deletion<<id
      end
    end
  elsif delid.include? ','
    list = delid.split(',')
    snapid.each do |id|
      if list.include? id.to_s 
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  elsif delid.include? 'c='
    snapid.each do |id|
      if readinfo(id)[2].include? delid.sub('c=','')
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  elsif delid.include? 'k='
    snapid.each do |id|
      if readinfo(id)[3] == delid.sub('k=','')
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  else
    if snapid.include? delid.to_i
        showinfo(delid)
        marked_for_deletion<<delid
    end
  end
    if marked_for_deletion.empty?
      puts "No snapshot meets the given criteria. ABORTED."
      abort
    end
  puts "Confirm deletion of the selected snapshots above? [y/N]"
  ans = STDIN.gets.chomp
  if ans == 'y' 
    puts "Confirmed. Proceeding..."
    marked_for_deletion.each do |id|
      @code = `btrfs subvolume delete #{@snapdir}/#{id}/data; echo $?`.to_i\
        + `rm -r #{@snapdir}/#{id}; echo $?`.to_i
    end
    if @code == 0 
      puts "Done."
    else
      puts "Oops... something went wrong. :-("
    end
  else #if choosed N
    puts "ABORTED."
  end
end
#==================================
def update
  pkg = ''
  update = `xbps-install -Mun`
  if update.empty?
     puts "There are no updates."
     abort
   else
     puts "Updates available:"
     pkgs = []
     kernel_update=false
     update.split("\n").each do |u|
       item = u.split(' ')
       puts "* #{item[0]} #{item[1]}"
       pkgs<<"(#{item[1][0]})-#{item[0]}"
       if item[0].include? 'linux' then kernel_update=true end
     end
   end
  puts "Proceed? [Y/n]"
  ans = STDIN.gets.chomp
  unless ans == 'n'
    snapshot("pre update: #{pkgs.join(', ')}",false)    
    puts `xbps-install -Suy`
    id = snapid.last
    snapshot("post [#{id}]",false)
    if kernel_update
      File.write('/tmp/snapxi-kernel-update',pkgs.join(', '),mode:'w')
      puts "================="
      puts "    IMPORTANT:"
      puts "================="
      puts "It seems you have upgraded the kernel." 
      puts "It is recommended that you reboot the system before using snapxi again."
    end
  else
    puts "ABORTED."
  end
 end
#==================================
opt = ARGV[0]
#==================================
if opt == 'snapshot'
  snapshot(ARGV[1],false)
end

if opt == 'list'
  list
end

if opt == 'rollback'
  if ARGV[1].nil?
    list; rollback
  else
    rollback
  end
end

if opt == 'delete'
  if ARGV[1].nil?
    list; delete
  else 
    delete
  end
end

if opt == 'update'
  update
end

if opt == 'help' 
  puts 'USAGE: snapxi <snapshot [COMMENT] | delete | rollback | update | list>'
end

