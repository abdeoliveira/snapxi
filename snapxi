#!/usr/bin/ruby

#===============
@device = '/dev/mapper/luks-cb826ef1-c466-4b9b-b11c-2b7b8fab5210' 
@snapdir = '/.snapshots'
@snapvol = '@snapshots'
#===============
unless ENV['USER'] == 'root'
  puts "You should run as root. ABORTED."
  abort
end
#==========================
def now
 Time.new.strftime "%Y.%m.%d,%H:%M:%S"
end
#==========================
def snapid
  ids = `btrfs subvolume list / | grep #{@snapvol}/`
  id_list=[]
  ids.split("\n").each do |i|
    id_list<<i.split('/')[1]
  end
  return id_list
end
#==========================
def snapshot(comm,pkg)
  id = snapid.last.to_i + 1
  path = @snapdir + '/' + id.to_s
  ker = `uname -r`.chomp
  `mkdir #{path}`
  if comm.nil? then comm = 'manual' end
  puts `btrfs subvolume snapshot / #{path}/data`
  info = "#{now},#{comm},#{ker}"
  File.write("#{path}/info",info,mode:'w')
  File.write("#{path}/pkgs",pkg,mode:'w')
end
#==========================
def readinfo(id)
  path = @snapdir + '/' + id.to_s
  info = File.read(path + '/info').split(',')
  pkgs = File.read(path + '/pkgs').split(',')
  date  = info[0]
  time  = info[1]
  desc  = info[2]
  comm = desc[0..15]
  ker  = info[3]
  return [date,time,comm,ker,pkgs]
end
#==========================
def list
    pklist = '' 
    line = 70
    puts "="*line
    puts " "*(line/2)+"SNAPSHOTS"
    puts "="*line
    puts "  ID  DATE        TIME      KERNEL   COMMENT            PKGS"
    puts "-"*line
    snapid.each do |id|
      date = readinfo(id)[0]
      time = readinfo(id)[1]
      comm = readinfo(id)[2]
      ker = readinfo(id)[3]
      pkgs = readinfo(id)[4]
      pklist = '' 
      unless pkgs.empty?
        pklist = pkgs[0]+"\n"
        pkgs.each_with_index do |p,j|
          unless j==0 
            pklist = pklist + ' '*55 + p + "\n" 
          end
        end
      end
      if id.to_i >= 10 then space = " " end
      if id.to_i < 10 then space = "  " end
      puts "#{space}[#{id}] #{date}  #{time}  #{ker}  #{comm}\
        #{pklist.strip}"
    end
    puts "-"*line 
end
#============================
def rollback
  timer = 5 # seconds before rebooting
  puts "Choose a snapshot ID to rollback," 
  puts "or any letter to ABORT:"
  id = STDIN.gets.strip.to_i
  if id <= @snap.length - 1 
    puts "Rolling back to snapshot ID [#{id}]: #{@snap[id]}."
  else
    puts "ABORTED."
    abort
  end
  puts "Confirm? [y/N]"
  confirm = STDIN.gets.chomp
  if confirm == 'y' 
    `mount #{@device} /mnt`
    `mv /mnt/@ /mnt/@snapshots/#{now}_pre+rollback`
    `btrfs subvolume snapshot /mnt/@snapshots/#{@snap[id]} /mnt/@`
    `echo "#{@snap[id]}" > /mnt/@snapshots/.RUNNING_SNAPSHOT`
    `umount /mnt`
    puts "Confirmed. Rebooting in..."
      timer.times do |i| 
        puts timer-=1
        sleep 1
      end
      puts 'Buckle up!'
    `reboot`
    else
      puts "ABORTED."
    end
end
#==================================
def showinfo(id)
  date = readinfo(id)[0]
  time = readinfo(id)[1]
  comm = readinfo(id)[2]
  ker = readinfo(id)[3]
  puts "[#{id}] #{date} #{time} #{ker} #{comm}" 
end
#==================================
def delete
  marked_for_deletion=[]
  puts "Select snapshot(s) to delete."
  puts "Choose [a] to ABORT:"
  delid = STDIN.gets.chomp
  if delid == 'a' 
    puts "ABORTED."
    abort
  end
  puts "Deleting snapshot(s):"
  if delid.include? '-'
    delid_i = delid.split('-').first.to_i
    delid_f = delid.split('-').last.to_i
    if delid_i >= delid_f 
      puts "Bad range. ABORTED."
      abort 
    end
    snapid.each do |id|
      if id.to_i >= delid_i and id.to_i<=delid_f 
          showinfo(id) 
          marked_for_deletion<<id
        end
    end
  elsif delid.include? ','
    list = delid.split(',')
    snapid.each do |id|
      if list.include? id.to_s 
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  elsif delid.include? 'c='
    snapid.each do |id|
      if readinfo(id)[2].include? delid.sub('c=','')
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  elsif delid.include? 'k='
    snapid.each do |id|
      if readinfo(id)[3] == delid.sub('k=','')
        showinfo(id) 
        marked_for_deletion<<id
      end
    end
  else
    showinfo(delid)
    marked_for_deletion<<delid
  end
  puts "Confirm? [y/N]"
  ans = STDIN.gets.chomp
  if ans == 'y' 
    puts "Confirmed. Proceeding..."
    marked_for_deletion.each do |id|
      @code = `btrfs subvolume delete #{@snapdir}/#{id}/data;echo $?`.to_i
        #+  `rm -r #{@snapdir}/#{id};echo $?`.to_i
    end
    if @code == 0 
      puts "Done."
    else
      puts "Oops... something went wrong. :-("
    end
  else
    puts "ABORTED."
  end
end
#==================================
def update
  pkg = ""
  update = `xi -Mun`
  if update.empty?
     puts "There are no updates."
     abort
   else
     puts "Updates available:"
     update.split("\n").each do |u|
       item = u.split(' ')
       puts "* #{item[0]} #{item[1]}"
       exc = '_' + item[0].split('_').last 
       pkg = pkg + ",#{item[0].sub(exc,'').delete('_')}"
     end
     pkg = pkg.sub(',','')
   end
  puts "Proceed? [Y/n]"
  ans = STDIN.gets.chomp
  unless ans == 'n'
    snapshot('pre update',pkg)    
    #puts `xi -Suy`
    id = snapid.last.to_i
    snapshot("post [#{id}]",'')
  else
    puts "ABORTED."
  end
 end
#==================================
opt = ARGV[0]
#==================================
if opt == 'snapshot'
  snapshot(ARGV[1],'')
end

if opt == 'list'
  list
end

if opt == 'rollback'
  list; rollback
end

if opt == 'delete'
  list; delete
end

if opt == 'update'
  update
end

if opt == 'help' or opt == '' 
  puts 'USAGE: snapxi <snapshot [COMMENT] | delete | rollback | update | list>'
end

